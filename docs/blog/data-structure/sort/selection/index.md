# 选择排序

选择排序的基本思想：每一趟从待排序的记录中选出关键字最小的记录，按顺序放在已排序的记录序列的最前，直到全部排完为止。

## 简单选择排序

**简单选择排序**（Simple Selection Sort）也称作直接选择排序。

算法步骤：

1. 设待排序的记录存放在数组 $r[0 \ldots n-1]$ 中。第一趟从 $r[0]$ 开始，通过 $n-1$ 次比较，从 $n$ 个记录中选出关键字最小的记录，记为 $r[k]$，交换 $r[0]$ 和 $r[k]$；
2. 第二趟从 $r[1]$ 开始，通过 $n-2$ 次比较，从 $n-1$ 个记录中选出关键字最小的记录，记为 $r[k]$，交换 $r[1]$ 和 $r[k]$；
3. 依次类推，第 $i$ 趟从 $r[i-1]$ 开始，通过 $n-i$ 次比较，从 $n-i+1$ 个记录中选出关键字最小的记录，记为 $r[k]$，交换 $r[i-1]$ 和 $r[k]$；
4. 经过 $n-1$ 趟，排序完成。

算法如下：

<<< ./select-sort.ts

### 时间复杂度

简单选择排序过程中，需要记录移动的次数较少。最好情况（正序）：不移动；最坏情况（逆序）：移动 $3(n-1)$ 次。

然而，无论记录的初始排列如何，所需进行的关键字比较次数相同，均为

$$
KCN=\sum_{i=1}^{n-1}(n-i)=\frac{n(n-1)}{2} \approx \frac{n^2}{2}
$$

因此，简单选择排序的时间复杂度是 $O(n^2)$。

### 空间复杂度

与冒泡排序一样，只有在两个记录交换时需要一个辅助空间，所以空间复杂度为 $O(1)$。

### 特点

- 排序方法本身是稳定的，但因为上述算法实现采用了“交换记录”的策略，造成了不稳定的现象。改变这个策略，可以写出稳定的算法；
- 可用于链式存储结构；
- 移动记录次数较少，当每一记录占用的空间较多时，此方法比直接插入排序快。

从上述可见，选择排序的主要操作是进行关键字的比较，因此改进简单选择排序应从如何减少比较次数考虑。显然，在 $n$ 个关键字中选出最小值，至少要进行 $n-1$ 次比较，然而，继续在剩余的 $n-1$ 个关键字中选择次小值并非一定要进行 $n-2$ 次比较，若能利用前 $n-1$ 次比较所得信息，则可减少以后各趟排序中的比较次数。现实生活中，体育比赛中的锦标赛就是一种选择排序。例如，在 8 个运动员中决出前 3 名至多需要 11 场比赛，而不是 $7+6+5=18$ 场比赛（它的前提是，若乙胜丙，甲胜乙，则认为甲必胜丙）。

![championships](./championships.png)

如上图，最底层的 8 个选手经过第一轮的 4 场比赛之后选出 4 个优胜者，然后经过两场半决赛和一场决赛之后，选出冠军。显然，按照锦标赛的传递关系，亚军只能产生于分别在决赛、半决赛和第一轮比赛中输给冠军的选手中。由此，在经过“CHA”和“LIU”、“CHA”和“DIAO”的两场比赛之后，选出亚军，同理，选出季军的比赛只要在“ZHAO”、“LIU”和“DIAO”3 个选手之间进行即可。按照这种思想可导出树形选择排序。

## 树形选择排序

**树形选择排序**（Tree Selection Sort），又称**锦标赛排序**（Tournament Sort），是一种按照锦标赛的思想进行选择排序的方法。首先对 $n$ 个记录的关键字进行两两比较，然后在其中 $\lceil \frac{n}{2} \rceil$ 个较少者之间再进行两两比较，如此重复，直至选出最小关键字的记录为止。这个过程可用一颗有 $n$ 个叶子结点的完全二叉树表示。

![tree selection sort](./tree-selection-sort.png)

如上图中的二叉树，表示从 8 个关键字中选出最小关键字的过程。8 个叶子结点中依次存放排序之前的 8 个关键字，每个非终端结点中的关键字均等于其左、右孩子结点中较小的关键字，则根结点中的关键字即为叶子结点中的最小关键字。在输出最小关键字之后，根据关系的可传递性，欲选出次小关键字，仅需将叶子结点中的最小关键字改为“最大值”，然后从该叶子结点开始，和其左（或右）兄弟的关键字进行比较，修改从叶子结点到根的路径上各结点的关键字，则根结点的关键字即为次小关键字。同理，可依次选出从小到大的所有关键字。由于含有 $n$ 个叶子结点的完全二叉树的深度为 $\lceil \log_2n \rceil + 1$，则在树形选择排序中，除了最小关键字外，每选择一个次小关键字仅需进行 $\lceil \log_2n \rceil$ 次比较，因此，它的时间复杂度为 $O(n\log_2n)$。但是，这种排序方法还有以下缺点：

- 需要较多辅助存储空间；
- 需要和最大值进行多余的比较。

为了改进这些缺点，J.Willioms 在 1964 年提出了另一种形式的选择排序 —— 堆排序。
